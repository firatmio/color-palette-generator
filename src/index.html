<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="index.css">
  <title>Color Palette Generator</title>
  <style>
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-center">
      <input id="base-hex-input" class="hex-input" type="text" maxlength="7" placeholder="#RRGGBB" title="Paletin ana rengi (hex)" />
    </div>
  </div>
  <div class="palettes">
    <div class="palette"><div class="overlay"><span></span></div></div>
    <div class="palette"><div class="overlay"><span></span></div></div>
    <div class="palette"><div class="overlay"><span></span></div></div>
    <div class="palette"><div class="overlay"><span></span></div></div>
    <div class="palette"><div class="overlay"><span></span></div></div>
  </div>
  <div class="control-area">
    <div class="info">
      <span>
        Created with ❤️ by <a title="github: firatmio" href="https://github.com/firatmio" onclick="openExternalLink(event, 'https://github.com/firatmio')">firatmio</a>.
      </span>
    </div>
    <div class="controls">
      <button class="control-button" onclick="downloadPalette()" title="export → 'palette.json'">
        <span>Export</span>
      </button>
      <button class="control-button" onclick="generatePalette()" title="Generate">
        <span>Generate</span>
      </button>
    </div>
  </div>

  <script>    
    function openExternalLink(event, url) {
      event.preventDefault();
      try {
        const { shell } = require('electron');
        shell.openExternal(url);
      } catch (error) {
        window.open(url, '_blank');
      }
    }

    function downloadPalette() {
        const palettes = document.querySelectorAll('.palette');
        const colors = Array.from(palettes).map(p => {
          let c = p.style.background || '';
          if (c && c.startsWith('#')) return c.toUpperCase();
          const rgb = getComputedStyle(p).backgroundColor;
          const m = rgb && rgb.match(/\d+/g);
          if (!m) return '#000000';
          const [r, g, b] = m.map(Number);
          return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();
        });
        const blob = new Blob([JSON.stringify({ colors }, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'palette.json';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }
    function hslToHex(h, s, l) {
      s /= 100; l /= 100;
      const k = n => (n + h / 30) % 12;
      const a = s * Math.min(l, 1 - l);
      const f = n => {
        const val = l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);
        return Math.round(255 * val).toString(16).padStart(2, '0');
      };
      return `#${f(0)}${f(8)}${f(4)}`.toUpperCase();
    }

    function getContrastColor(hex) {
      hex = hex.replace("#", "");
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.5 ? "#000000" : "#FFFFFF";
    }

    // Yardımcılar
    function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

    function isValidHex(input) {
      if (!input) return false;
      const s = input.trim();
      return /^#?[0-9a-fA-F]{6}$/.test(s) || /^#?[0-9a-fA-F]{3}$/.test(s);
    }

    function normalizeHex(input) {
      let s = (input || '').trim();
      if (!s) return '#000000';
      if (s[0] !== '#') s = '#' + s;
      if (/^#[0-9a-fA-F]{3}$/.test(s)) {
        const r = s[1], g = s[2], b = s[3];
        s = `#${r}${r}${g}${g}${b}${b}`;
      }
      return s.toUpperCase();
    }

    function hexToHsl(hex) {
      hex = normalizeHex(hex).slice(1);
      const r = parseInt(hex.substr(0,2),16) / 255;
      const g = parseInt(hex.substr(2,2),16) / 255;
      const b = parseInt(hex.substr(4,2),16) / 255;
      const max = Math.max(r,g,b), min = Math.min(r,g,b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0; // achromatic
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h *= 60;
      }
      return { h: Math.round(h || 0), s: Math.round((s||0)*100), l: Math.round(l*100) };
    }

    // Paletin merkez rengi baz alınarak tonlar üret (orta = base)
    function createPaletteFromBase(baseHex, count) {
      const base = hexToHsl(baseHex);
      const center = Math.floor(count / 2);
      // sınırlar içinde kalacak adım seçimi
      let step = Math.max(10, Math.floor(Math.min(base.l - 12, 88 - base.l) / 2));
      if (!isFinite(step) || step <= 0) step = 12;
      const colors = [];
      for (let i = 0; i < count; i++) {
        const offset = (i - center) * step;
        const l = clamp(base.l + offset, 12, 88);
        colors.push(hslToHex(base.h, base.s, l));
      }
      colors[center] = normalizeHex(baseHex); // tam merkez, girilen hex
      return colors;
    }

    function createRandomBaseHex() {
      const isGray = Math.random() < 0.25;
      const h = isGray ? 0 : Math.floor(Math.random() * 360);
      const s = isGray ? 0 : 60 + Math.floor(Math.random() * 20);
      const l = 50 + Math.floor(Math.random() * 10); // 50..59 arası orta ton
      return hslToHex(h, s, l);
    }

    let paletteHistory = [];

    function generatePalette(baseHex) {
      const palettes = document.querySelectorAll(".palette");
      const count = palettes.length;

      // Base hex belirle
      let base = baseHex && isValidHex(baseHex) ? normalizeHex(baseHex) : createRandomBaseHex();

      // Benzersiz palet bul (geçmişe göre)
      let attempts = 0;
      let colors = [];
      let key = '';
      const MAX_ATTEMPTS = 100;
      do {
        colors = createPaletteFromBase(base, count);
        key = colors.join(',');
        if (paletteHistory.includes(key)) {
          // Çakıştıysa yeni bir base üret ve tekrar dene
          base = createRandomBaseHex();
        }
        attempts++;
      } while (paletteHistory.includes(key) && attempts < MAX_ATTEMPTS);

      palettes.forEach((palette, i) => {
        const color = colors[i];
        const textColor = getContrastColor(color);
        palette.style.background = color;
        const span = palette.querySelector("span");
        span.textContent = color;
        span.style.color = textColor;

        palette.onclick = () => {
          navigator.clipboard.writeText(color).then(() => {
            span.textContent = "Copied!";
            setTimeout(() => { span.textContent = color; }, 1000);
          });
        };
      });

      if (!paletteHistory.includes(key)) {
        paletteHistory.push(key);
        if (paletteHistory.length >= 50) {
          paletteHistory = [];
        }
      }

      // Input değerini güncelle
      const input = document.getElementById('base-hex-input');
      if (input) input.value = colors[Math.floor(count/2)];
    }

    // Input etkileşimi: geçerli hex olduğunda paleti güncelle
    const baseHexInput = document.getElementById('base-hex-input');
    let inputDebounce;
    if (baseHexInput) {
      baseHexInput.addEventListener('input', () => {
        clearTimeout(inputDebounce);
        inputDebounce = setTimeout(() => {
          const v = baseHexInput.value;
          if (isValidHex(v)) {
            generatePalette(v);
          }
        }, 250);
      });
      baseHexInput.addEventListener('change', () => {
        const v = baseHexInput.value;
        if (isValidHex(v)) generatePalette(v);
      });
    }

    // İlk yüklemede rastgele bir palet
    generatePalette();
  </script>
</body>

</html>